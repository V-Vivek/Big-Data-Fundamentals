# Database Scaling Patterns

## A Case Study - Cab Booking App
- Tiny startup.
- ~10 customers onboard.
- A single small machine DB stores all customers, trips, locations, booking data, and customer trip history.
- ~1 trip booking in 5 mins.

## PROBLEM #1
- Requests scales upto 30 bookings per minute.
- Your tiny DB system has started performing poorly.
- API latency has increased a lot.
- Transactions facing Deadlock, Starvation, and frequent failure.
- Sluggish App experience.
- Customer dis-satisfaction.

# Pattern 1: Query Optimisation & Connection Pool Implementation
- Cache frequently used non-dynamic data like, booking history, payment history, user profiles etc. (Store it in app data on users device)
- Introduce Database Redundancy it will reduce overhead of JOINING tables. (Or may be use NoSQL)
- Use connection pool libraries to Cache DB connections.
  - The primary purpose of a connection pool library is to reduce the overhead of establishing new database connections by reusing existing connections.
  - Multiple application threads can use same DB connection.  
*** Good optimisations as of now ***

## PROBLEM #2
Scaled the business to one more city, and now getting ~100 booking per minute.

# Pattern 2: Vertical Scaling or Scale-up
- Upgrading our initial tiny machine.
- RAM by 2x and SSD by 3x etc.
- Scale up is pocket friendly till a point only.
- More you scale up, cost increases exponentially.  
*** Good optimisations as of now ***

## PROBLEM #3
Business is growing, you decided to scale it to 3 more cities and now getting 300 booking per minute.

# Pattern 3: Command Query Responsibility Segregation (CQRS)
- The scaled up big machine is not able to handle all read/write requests.
- Separate read/write operations physical machine wise.
- 2 more machines as replica to the primary machine.
- All read queries to replicas.
- All write queries to primary.  
*** Good optimisations as of now ***

## PROBLEM #4
- Business is growing, you decided to scale it to 2 more cities.
- Primary is not able to handle all write requests.
- Lag between primary and replica is impacting user experience.
